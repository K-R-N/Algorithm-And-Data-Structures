import java.util.*;

class MultiSet extends AbstractMultiSet {
  /**
   * Creates a new MultiSet that will contain the elements from `elements`.
   * The list of elements will be sorted in the constructor of the superclass.
   *
   * @param elements
   *     The list of elements that this MultiSet will contain.
   */
  public MultiSet(List<Integer> elements) {
    super(elements);
  }

  /**
   * Creates a new, empty MultiSet.
   */
  public MultiSet() {
    super();
  }

  /**
   * @param element
   *     the integer element to search for.
   * @return the number of occurrences of `element` in `this` multiset.
   */
  @Override
  public int count(int element) {
    ArrayList<Integer> arr = (ArrayList<Integer>) this.getElements();
    int count = 0;
    for(int i =0; i < arr.size(); i++ ){
      if(arr.get(i) == element) count++;
    }
    return count;
  }

  /**
   * Calculates the union between `this` and `other`.
   * In the union of `this` and `other`, the frequency of each distinct element in the result set is defined as follows:
   * Given `C = A.union(B)`. Then for every integer `i`, `C.count(i) == max(A.count(i), B.count(i))`.
   *
   * @param other
   *     the other multiset to take the union with.
   * @return The union of multisets `this` and `other`.
   */
  @Override
  public AbstractMultiSet union(AbstractMultiSet other) {
    if(other == null) return this;
    ArrayList<Integer> result = new ArrayList<>();
   
    ArrayList<Integer> e1 = (ArrayList<Integer>) this.getElements();
    ArrayList<Integer> e2 = (ArrayList<Integer>) other.getElements();
    
    for(int i = 0; i < e1.size(); i++){
      if(this.count(e1.get(i)) >= other.count(e1.get(i))){
        result.add(e1.get(i));
      }
    }
    for(int i = 0; i < e2.size(); i++){
      if(other.count(e2.get(i)) > this.count(e2.get(i))){
        result.add(e2.get(i));
      }
    }
    return new MultiSet(result);
  }
}
/*
Implement the union and count methods of a multiset.

A multiset is a set in which elements can occur multiple times. The elements are stored as a sorted list. All operations on the multiset should make sure that this list remains sorted. The class AbstractMultiSet as defined in the visible Library code sorts the elements list in the constructor.

You will need to extend AbstractMultiSet with two methods:

    count(int element) - Returns the number of occurrences of element in this multiset.
    union(AbstractMultiSet other) - Returns a new multiset that contains all elements from both sets, where the frequency of each distinct element is defined as follows:

    Given C = A.union(B). Then for every integer i, C.count(i) == max(A.count(i), B.count(i)).

    See the visible tests for an example of this.

You should treat null as an empty multiset.

*/
